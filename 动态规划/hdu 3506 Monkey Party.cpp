//香蕉森林里一群猴子（n<=1000)围成一圈开会，会长给他们互相介绍，每个猴子需要时间a[i]。
//每次只能介绍相邻的两只猴子x和y认识，同时x所有认识的猴子和y所有认识的猴子也就相互认识了，
//代价为这两伙猴子认识的时间（a[i]）之和。求这群猴子都互相认识的最短时间。
//这道题其实就是环形的石子合并问题，首先将环形dp转化为线性dp，对于长度为n的环，任意选取一点为起点，
//由起点开始得到一条长度为n的链，将前面n-1长度的链复制并转移到链的末端，相当于将两条同样的链首尾相接。
//这样环的任意一种单向遍历方式都可以在这个长度这为2n-1的链中实现。
//可见曾妞妞的《怎样实现环形动态规划问题》。
// 环形DP,可以设为2 * n，转化为链状，四边形不等式优化
// 转移方程f[i][j] = f[i][k] + f[k + 1][j] + sum[i][j];
// 必须使用四边形优化,成为n^2复杂度，否则复杂度n^3,超时
//【解题思路】
// 令f[i,j]表示归并第i个数到第j数的最小代价,sum[i,j]表示第i个数到第j个数的和，这个可以事先计算出来。
// sum[i,j]可以在O(1)的时间内算出.
// 容易的到以下的动态转移方程：
// 阶段：以归并石子的长度为阶段，一共有n-1个阶段。
// 状态：每个阶段有多少堆石子要归并，当归并长度为2时，有n-1个状态；
// 当归并长度为3时，有n-2个状态；
// 当归并长度为n时，有1个状态。
// 决策：当归并长度为2时，有1个决策；当归并长度为3时，有2个决策；
// 当归并长度为n时，有n-1个决策。
// 归并长度len，起点i和决策点k三层循环，复杂度O(n^3)，n<=1000肯定TLE。
// 四边形不等式优化DP：
// 优化k!!!    （k是i···j的分割点）
// 原来我是从i···j-1枚举k, 取f(i,j)=min{f[i,k]+f[k+1,j]}+sum(i,j);
// 而实际上我只需要从s[i,j-1]到s[i+1,j]枚举k就可以了。其中s[i,j]指f[i...j]取最优解的分割点，
// 这样复杂度就变成O(n^2).
// PS:四边形不等式优化DP，读者可以阅读：华中师大一附中  赵爽《动态规划加速原理之四边形不等式》。
// 环形石子归并：
// 本题目属于环形石子归并类型，可以令n乘以2模拟环；亦可以取模运算。最后枚举判断环的起点（终点=起点+n-1），
// 得到最小代价。
#include <stdio.h>
#include <iostream>
using namespace std;
#define maxn 2006
#define INF 99999999
int a[maxn], fmin[maxn][maxn], sum[maxn][maxn], s[maxn][maxn], n, mmin;
//fmin[i][j] i到j的所有人都认识花的最小时间
//sum[i][j] i到j的自我介绍的时间总和
//s[i][j] 记录i到j如要全部认识，在哪起分为两部分所花的时间最少
int main()
{
    int i, j, k, len;
    while (scanf("%d", &n) != -1)
    {
        for (i = 1; i <= n; i++)
        {
            scanf("%d", &a[i]);
            a[i + n] = a[i];
        }
        memset(sum, 0, sizeof(sum));
        for (i = 1; i < 2 * n; i++)
        {
            s[i][i] = i;
            fmin[i][i] = 0;
            for (j = i; j <= i + n && j <= 2 * n; j++)
                sum[i][j] = sum[i][j - 1] + a[j];
        }
        //下面这段代码比较难理解啊
        for (len = 2; len <= n; len++)
        {
            for (i = 1; i <= 2 * n - len + 1; i++)
            {
                j = i + len - 1;
                fmin[i][j] = INF;
                for (k = s[i][j - 1]; k <= s[i + 1][j]; k++) //四边形优化，缩小了取值范围
                {
                    if (fmin[i][j] > fmin[i][k] + fmin[k + 1][j] + sum[i][j])
                    {
                        fmin[i][j] = fmin[i][k] + fmin[k + 1][j] + sum[i][j];
                        s[i][j] = k;
                    }
                }
            }
        }
        int mmin = INF;
        for (i = 1; i <= n; i++)
            mmin = min(fmin[i][i + n - 1], mmin);
        printf("%d\n", mmin);
    }
}